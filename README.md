# Homework3

## Задача: 
> 1. Разработать пользовательскую структуру данных MyLinkedList
> 2. Написать тестовый класс, измеряющий с помощью System.nanoTime()
> время выполнения основных операций для LinkedList, MyLinkedList, ArrayList, HashSet, LinkedHashSet, TreeSet, HashMap, LinkedHashMap, TreeMap.

## Комментарии:
>С разработкой пользовательской структуры я справился успешно. Была
> проведена проверка основного функционала в классе
> "TestMainFunctionality". Переходя ко второй части домашнего задания, а
> именно к тестированию производительности я столкнулся с проблемой,
> замеряя время с помощью System.nanoTime() или любым другим подобным инструментом,
> значения получались некорректные для следующих после первой структур
> данных, это происходило потому что я не изолировал работу с коллекциями друг от друга, поэтому при 
> переходе к следующим после первой коллекциям не могло гарантироваться как минимум отработка сборщика
> мусора который при таких объемах данных съедает ощутимую часть времени. Вроде как я нашёл, как правильно
> тестировать производительность кода с помощью JMH, но для работы с ним потребуется как минимум сборщик
> проекта, поэтому эту идею я откинул. Подумал про отделение этих операций с помощью создания разных потоков, но
> потом вспомнил, что тестируемые структуры данных не потокобезопасны и я подумал, что особой разницы, как костылять
> нет, поэтому решил отделить работу с каждой коллекцией с помощью switch. В плане юзабилити получилось не очень, так
> как для проверки результатов надо всегда перезапускать программу и выбирать нужный пункт, зато результат, выдаваемый
> моими тестами достоверен. Это было объяснение, почему класс "TestPerformance" такой некрасивый, странный и тд.

## Выводы:
> Добавление:
> * LinkedList      2952377100
> * MyLinkedList    2867636800
> * ArrayList       173536000
> * HashSet         2223899000
> * LinkedHashSet   2155604700
> * TreeSet         5058434100
> * HashMap         5892040500
> * LinkedHashMap   2019198400 - 4486687400
> * TreeMap         5011601400

> Поиск:
> * LinkedList      17045300
> * MyLinkedList    17442100
> * ArrayList       7600
> * HashMap         13600
> * LinkedHashMap   15800
> * TreeMap         32700 

> Удаление:
> * LinkedList      9700    25905500    9300
> * MyLinkedList    5700    18288000    5700
> * ArrayList       3486200 1781100     4200
> * HashSet         9000   
> * LinkedHashSet   26400
> * TreeSet         27100
> * HashMap         9300
> * LinkedHashMap   10600
> * TreeMap         38300

> Вставка:
> * LinkedList      9900        17206300    9500
> * MyLinkedList    5700        16501700    5300
> * ArrayList       3851600     1814000     6600

> Изменение:
> * LinkedList      9600        26667400  9000
> * MyLinkedList    6100        40050000  6300
> * ArrayList       5700        5600      5800

## Выводы:
> 1. LinkedList & MyLinkedList vs ArrayList. Тестирование показало, что ArrayList лидирует во всех дисциплинах, 
> за исключением операций вставки и удаления элемента в/из начало списка. Несмотря на то, что с точки зрения теории
> операции вставки и удаления в ArrayList должны работать медленно по сравнению с LinkedList, так для вставки или удаления
> элемента ArrayList копирует и сдвигает каждый элемент, а в LinkedList всего лишь происходит изменение ссылки будущих/бывших соседей,
> но этих соседей ещё предстоит найти, а поиск элемента это слабое звено LinkedList, поэтому на практике получается, что вставка и удаление
> элемента в ArrayList, если говорить про центр списка, работает на порядок быстрее чем в LinkedList и практически в два раза быстрее чем в конец, но
> если проводить эти операции с началом списка, то ArrayList начинает работать чудовищно медленно по сравнению с LinkedList. Если говорить про операции
> взятия элемента и изменения элемента (get, set), то тут, как и должно быть ArrayList работает на порядки быстрее. Добавление большого количества
> элементов работает на порядок быстрее в ArrayList. Что использовать? Если планируется частая работа с началом списка (вставка/удаление) LinkedList, во всех
> остальных случаях ArrayList.
> 2. HashSet, LinkedHashSet, TreeSet. С точки зрения теории, HashSet должен быть самый быстрый, LinkedHashSet должен быть чуть медленнее HashSet или такой же, a
> TreeSet самый медленный среди этой троицы из-за операций сортировки. Практика подтвердила теорию. В каких случаях удобно использовать ту или иную коллекцию из этой
> троицы? Если нам просто надо хранить добавленные элементы без сохранения какой-либо последовательности, то стоит воспользоваться HashSet, если необходимо поддерживать
> порядок вставки, то LinkedHashSet, и TreeSet в котором поддерживается порядок элементов по сортировки.
> 3. HashMap, LinkedHashMap, TreeMap. С точки зрения теории производительность HashMap и LinkedHashMap одинакова (O(1)), а TreeMap O(log(n)). Практика показала следующее:
> get, put, remove в единичном использовании в плане производительности подчиняются теории, если рассматривать многочисленное get, put, remove, то для get и remove странностей
> нет, а вот для put результаты следующие: HashMap работает медленнее всех, LinkedHashMap быстрее всех, иногда даже в 2 раза быстрее HashMap и TreeMap, TreeMap в середине по
> производительности, но имеет самый маленький разброс. Операция clean: работает одинаково по скорости для HashMap и LinkedHashMap, а для TreeMap практически моментально, тк
> для очистки дерева достаточно убить корень. Что использовать? Опять же всё зависит от задачи, если необходимо просто хранить пару ключ-значение без поддержания какого-либо
> порядка изаем HashMap, если нужна поддержка порядка вставки элемента LinkedHashMap, если нужная сортировка по ключу TreeMap.